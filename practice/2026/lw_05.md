# Лабораторная работа 5. Оптимизация запросов с помощью индексов и анализа плана выполнения

**СУБД:** PostgreSQL  
**Источник данных:** `bi_sql_data_student_dump.sql` (Основной источник Глава 8. Performant SQL)


## Цель работы
Научиться анализировать производительность SQL-запросов, интерпретировать план выполнения (Query Plan) и оптимизировать работу базы данных с помощью различных типов индексов (B-tree, Hash).

## Задачи
1.  Изучить принципы работы планировщика запросов (Query Planner) в PostgreSQL.
2.  Освоить команды `EXPLAIN` и `EXPLAIN ANALYZE` для диагностики производительности.
3.  Сравнить методы сканирования таблиц: последовательное сканирование (Sequential Scan) и сканирование по индексу (Index Scan).
4.  Научиться создавать и применять индексы для ускорения выборок.
5.  **Важно.** Понять разницу между выполнением запросов на чтение (в промышленной среде) и оптимизацией (в среде разработки).

---

## ⚠️ Важно. Разделение сред выполнения

В данной лабораторной работе критически важно соблюдать регламент работы с серверами. Операции создания индексов (`CREATE INDEX`) являются ресурсоемкими и изменяют структуру БД, поэтому они **запрещены** на основном учебном сервере.

| Тип задания | Среда выполнения | Примечание |
| :--- | :--- | :--- |
| **Задание 1 (Анализ плана)** | **Основной сервер** | Выдается преподавателем. Права только на чтение. Здесь вы оцениваете "медленный" запрос. |
| **Задания 2* и 3* (Оптимизация)** | **Локально** | Требуют прав `CREATE`. Необходимо развернуть свою БД или использовать [VM (devops_dba_25.ova)](https://envlab.ru/mod/url/view.php?id=303). |

---

## Теоретическая часть

### Планирование запросов (Query Planning)
Перед выполнением любого SQL-запроса СУБД строит **план выполнения**. Планировщик выбирает наиболее эффективный способ извлечения данных, основываясь на статистике.

*   **`EXPLAIN query`** — показывает предполагаемый план *без* выполнения запроса.
*   **`EXPLAIN ANALYZE query`** — *выполняет* запрос и показывает реальное время выполнения (Execution Time) и стоимость (Cost).

### Стоимость (Cost)
В выводе `EXPLAIN` параметры выглядят так: `cost=0.00..123.45`.
*   `0.00` — затраты на старт (получение первой строки).
*   `123.45` — общие затраты на получение всех строк.

### Методы сканирования
1.  **Sequential Scan (Seq Scan).** Полный перебор строк таблицы. Используется, когда индексов нет или нужно прочитать большую часть таблицы. Это "медленный" метод для точечных запросов.
2.  **Index Scan / Bitmap Heap Scan.** Использование индекса для быстрого поиска. Эффективен для выборки малого количества строк.

### Типы индексов
*   **B-Tree.** Стандартный индекс. Подходит для сравнений (`<`, `=`, `>`), сортировки (`ORDER BY`) и диапазонов.
*   **Hash.** Подходит только для точного равенства (`=`).

---

## Практическая часть (Пример выполнения)

### Шаг 1. Анализ текущей производительности (Основной сервер)
Требуется найти клиентов из штата Калифорния. Выполняем на сервере преподавателя:

```sql
EXPLAIN ANALYZE
SELECT * FROM customers WHERE state = 'CA';
```

**Результат (пример):**
```text
Seq Scan on customers  (cost=0.00..1536.00 rows=50 width=144)
  Filter: (state = 'CA'::text)
Execution Time: 15.2 ms
```
*Вывод.* Используется `Seq Scan` (полный перебор), время 15.2 мс.

### Шаг 2. Оптимизация (Локальная среда)
Переходим в локальную базу данных (где развернут тот же дамп).

1.  **Создаем индекс:**
    ```sql
    CREATE INDEX idx_customers_state ON customers(state);
    ```
2.  **Повторяем анализ:**
    ```sql
    EXPLAIN ANALYZE
    SELECT * FROM customers WHERE state = 'CA';
    ```

**Результат (пример):**
```text
Bitmap Heap Scan on customers ...
  ->  Bitmap Index Scan on idx_customers_state ...
Execution Time: 1.5 ms
```
*Вывод.* Время сократилось в 10 раз, используется индекс.

3.  **Очистка (Локально):**
    ```sql
    DROP INDEX idx_customers_state;
    ```

---

## Индивидуальные задания

Выберите вариант `(Номер в списке % 30) + 1`.

*   **Задание 1.** Выполнить `EXPLAIN ANALYZE` на **Основном сервере**. Зафиксировать план (Seq Scan) и время.
*   **Задание 2*.** Выполнить тот же запрос **Локально**, создать индекс (B-Tree или Hash), проверить ускорение.
*   **Задание 3*.** Выполнить оптимизацию сложного запроса **Локально**.

[Варианты заданий на образовательном портале](https://envlab.ru/mod/assign/view.php?id=1056)

---

## Правила оформления отчета

1.  **Репозиторий.** Работа загружается в папку `lab_05` вашего репозитория.
2.  **Файл `README.md`:** Должен содержать отчет по структуре:
    *   **Вариант №X**
    *   **Задание 1 (Сервер):**
        *   Текст запроса.
        *   Скриншот плана (`Seq Scan`).
        *   Указание стоимости (Cost) и времени (Time).
    *   **Задание 2* (Локально):**
        *   Команда создания индекса.
        *   Скриншот нового плана (`Index Scan` / `Bitmap Scan`).
        *   **Сравнение:** "Время выполнения уменьшилось с X мс до Y мс".
    *   **Задание 3* (Локально):** Аналогично: запрос -> создание индекса -> новый план.
3.  **Скрипт.** Файл `lab_05.sql` с SQL-командами.
4.  **Сдача.** Ссылка на репозиторий в Moodle.

## Критерии оценки

*   **3 балла.** Выполнено только Задание 1 (анализ на основном сервере без оптимизации) или Задания 1 и 2 выполнены, но без доказательств локального создания индексов.
*   **4 балла.** Выполнены Задания 1 и 2*. Представлены скриншоты "До" (с сервера) и "После" (локально с индексом).
*   **5 баллов.** Выполнены все 3 задания (включая сложное). Отчет содержит грамотный анализ того, почему планировщик выбрал индекс (снижение Cost).
```


