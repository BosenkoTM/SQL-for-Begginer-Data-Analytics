# Лабораторная работа №5. SQL для подготовки данных

**СУБД:** PostgreSQL  
**Источник данных:** `bi_sql_data_student_dump.sql`

## 1. Цель работы
Научиться собирать данные из нескольких таблиц в единый набор данных (dataset) и применять функции очистки и трансформации данных для подготовки их к дальнейшему анализу.

## 2. Задачи
1. Изучить способы объединения таблиц с помощью операторов `JOIN` (INNER, LEFT, RIGHT, FULL, CROSS).
2. Научиться объединять результаты запросов с помощью `UNION` и `UNION ALL`.
3. Освоить функции условной логики и обработки NULL-значений: `CASE WHEN`, `COALESCE`, `NULLIF`.
4. Применить функции нормализации данных: `LEAST`/`GREATEST`, приведение типов (`CAST`), удаление дубликатов (`DISTINCT`).
5. Выполнить практические задания по формированию аналитических витрин данных.

## 3. Теоретическая часть

В аналитике до 80% времени занимает подготовка данных. Данные редко хранятся в одной таблице в готовом виде. Основные этапы подготовки включают сборку (Assembling) и трансформацию (Transforming).

### 3.1. Объединение таблиц (JOINS)
Для соединения таблиц используется ключевое слово `JOIN` в сочетании с условием `ON` (предикатом соединения).

*   **INNER JOIN**. Возвращает только те строки, для которых найдено совпадение в обеих таблицах.
*   **LEFT OUTER JOIN**. Возвращает все строки из левой таблицы. Если совпадение в правой таблице не найдено, столбцы правой таблицы заполняются значениями `NULL`.
*   **RIGHT OUTER JOIN**. Аналогично LEFT, но сохраняются все строки из правой таблицы.
*   **FULL OUTER JOIN**. Возвращает строки, если есть совпадение хотя бы в одной из таблиц (объединение множеств).
*   **CROSS JOIN**. Декартово произведение — каждая строка первой таблицы соединяется с каждой строкой второй таблицы.

### 3.2. Объединение запросов (UNIONS)
Позволяет объединить результаты двух и более запросов «вертикально» (добавить строки).
*   **UNION**. Объединяет результаты и **удаляет дубликаты**.
*   **UNION ALL**. Объединяет результаты, сохраняя все строки (включая дубликаты). Работает быстрее.
*   *Требование.* Количество и типы столбцов в объединяемых запросах должны совпадать.

### 3.3. Трансформация и очистка
*   **CASE WHEN**. Позволяет реализовать логику «ЕСЛИ-ТО-ИНАЧЕ» внутри запроса.
*   **COALESCE(val1, val2, ...)**. Возвращает первое **не-NULL** значение из списка. Идеально для замены пропусков (например, `COALESCE(phone, 'Не указан')`).
*   **NULLIF(val1, val2)**. Возвращает `NULL`, если `val1` равно `val2`. Полезно для предотвращения деления на ноль.
*   **LEAST / GREATEST**. Выбирает минимальное или максимальное значение из списка аргументов (построчно).
*   **DISTINCT**. Удаляет дублирующиеся строки из результата.
*   **DISTINCT ON (col)**. Оставляет только первую строку для каждого уникального значения указанного столбца (важен порядок `ORDER BY`).

## 4. Практическая часть (Общие задания)

Для выполнения заданий необходимо развернуть базу данных из дампа `bi_sql_data_student_dump.sql`.

### Задание 4.1. Сборка данных о продажах (JOIN)
**Задача.** Менеджеру требуется отчет о проданных автомобилях (имя клиента, модель, цена, дата).

**Решение:**
```sql
SELECT
    c.first_name,
    c.last_name,
    p.model,
    s.sales_amount,
    s.sales_transaction_date
FROM sales s
INNER JOIN customers c ON s.customer_id = c.customer_id
INNER JOIN products p ON s.product_id = p.product_id
WHERE p.product_type = 'automobile'
ORDER BY s.sales_transaction_date DESC
LIMIT 10;
```

### Задание 4.2. Список всех городов присутствия (UNION)
**Задача:** Составить единый список уникальных названий городов (клиенты + дилеры).

**Решение.**
```sql
SELECT city, 'Client City' as type FROM customers
UNION
SELECT city, 'Dealership City' as type FROM dealerships
ORDER BY city;
```

### Задание 4.3. Очистка данных и категоризация (Transformation)
**Задача.** Вывести список клиентов. Обработать пустые телефоны, добавить регион (West/East/Other).

**Решение:**
```sql
SELECT
    first_name,
    last_name,
    COALESCE(phone, 'No Phone') as contact_phone,
    CASE
        WHEN state IN ('CA', 'WA') THEN 'West'
        WHEN state IN ('NY', 'FL') THEN 'East'
        ELSE 'Other'
    END as region
FROM customers
LIMIT 20;
```

## 5. Индивидуальные задания

Выберите вариант задания в соответствии с вашим номером в списке группы.

| Вариант | Задание 1 (JOINs) | Задание 2 (Unions / Distinct) | Задание 3 (Transformation) |
| :--- | :--- | :--- | :--- |
| **1** | Выведите список всех продаж скутеров (scooter), включая модель, дату продажи и email клиента. | Составьте список всех уникальных почтовых индексов из таблиц `customers` и `dealerships`. | В таблице `products` создайте столбец `price_category`: если цена > 1000 — 'High', иначе 'Low'. |
| **2** | Покажите список сотрудников (`salespeople`) и адрес дилерского центра, в котором они работают. | Выведите имена (`first_name`) всех людей (клиентов и сотрудников) в алфавитном порядке без дублей. | В таблице `customers` замените `NULL` в столбце `suffix` на пустую строку, объединив его с фамилией. |
| **3** | Выведите детали продаж (дата, сумма) для клиентов из города 'New York City'. | Найдите штаты, в которых есть и клиенты, и дилерские центры (используйте `INTERSECT` или `JOIN`). | Рассчитайте скидку: разницу между `base_msrp` и `sales_amount`. Если разница отрицательная, выведите 0 (`GREATEST`). |
| **4** | Покажите все товары, которые ни разу не были проданы (используйте `LEFT JOIN` и проверку на `NULL`). | Объедините список email-адресов клиентов из таблиц `customers` и `emails` (уникальные). | Создайте столбец `season` для `sales`: Winter (дек-фев), Spring (март-май) и т.д. по дате транзакции. |
| **5** | Выведите список клиентов, которые кликнули (`clicked`) по ссылке в письме, с указанием темы письма. | Выведите список всех городов из таблицы `top_cities_data` и `dealerships`. | Используйте `NULLIF`, чтобы избежать деления на ноль при расчете отношения `sales_amount` / `base_msrp`. |
| **6** | Соедините таблицы `sales`, `products` и `dealerships`, чтобы показать продажи в штате 'CA'. | Получите список уникальных имен (`first_name`) клиентов, начинающихся на 'A'. | Преобразуйте `latitude` и `longitude` в таблице `customers` в целые числа (`::INTEGER`). |
| **7** | Выведите модель товара и имя продавца для каждой продажи. | Выведите список ID всех дилеров, участвовавших в продажах, и ID дилеров из справочника `dealerships`. | Если у клиента не заполнен `ip_address`, выведите 'Unknown IP' с помощью `COALESCE`. |
| **8** | Найдите клиентов, у которых почтовый индекс совпадает с индексом любого дилерского центра. | Составьте список всех дат: даты добавления клиентов и даты транзакций продаж (`UNION ALL`). | В таблице `products` создайте столбец `is_vintage`: 'Yes', если год выпуска < 2015, иначе 'No'. |
| **9** | Выведите список продуктов и количество раз, которое они были проданы (через `JOIN` и `GROUP BY`). | Получите список уникальных фамилий сотрудников и клиентов. | Сформируйте полное имя клиента в формате "Фамилия, И. О." (используя `SUBSTRING`). |
| **10** | Покажите продажи, совершенные через канал 'internet', с указанием модели продукта. | Выведите все штаты, где есть дилеры, но нет клиентов (можно через `EXCEPT` или `LEFT JOIN`). | Используйте `LEAST`, чтобы сравнить `sales_amount` и `base_msrp` и вывести меньшее значение. |
| **11** | Выведите имена клиентов и дату открытия ими письма (из таблицы `emails`), если письмо открыто. | Объедините названия моделей продуктов (`model`) и типы продуктов (`product_type`) в один список. | Если `gender` в таблице `customers` равен 'F', выведите 'Female', 'M' -> 'Male', иначе 'Unknown'. |
| **12** | Соедините `salespeople` и `dealerships`, чтобы найти сотрудников, работающих в 'Houston'. | Выведите уникальные года выпуска (`year`) продуктов и года основания стран (`founding_year`). | Замените все вхождения 'St' на 'Street' в адресах клиентов (`REPLACE`). |
| **13** | Найдите всех клиентов, купивших 'Model Chi'. | Выведите список всех ID транзакций и ID клиентов в один столбец. | Рассчитайте налог (10% от суммы), если сумма продажи не `NULL`, иначе 0. |
| **14** | Выведите список продаж с указанием города дилера. | Сформируйте справочник всех людей в базе: тип ('Client'/'Staff'), имя, фамилия. | Используйте `CAST` для преобразования `postal_code` в числовой формат (где это возможно). |
| **15** | Найдите товары, проданные в 2018 году (по дате транзакции). | Выведите список городов, встречающихся в таблице `customers` более 10 раз (`DISTINCT` не нужен, нужен `GROUP BY`). | Если `title` у клиента отсутствует, подставьте 'Dear Customer' (`COALESCE`). |
| **16** | Выведите имена клиентов, живущих в том же штате, где был куплен товар (через дилера). | Объедините (UNION) список `product_id` из таблицы `sales` и таблицы `products`. | Классифицируйте продажи: < 5000 -> 'Bronze', 5000-20000 -> 'Silver', > 20000 -> 'Gold'. |
| **17** | Покажите email-адреса клиентов, которые совершили покупку на сумму > 50000. | Выведите список уникальных доменов почты (все, что после @) из таблицы `customers`. | В таблице `dealerships` выведите дату закрытия или строку 'Active', если дата `NULL`. |
| **18** | Соедините `sales` и `salespeople`, чтобы узнать, кто продал товар с ID 100. | Выведите список всех широтных координат (`latitude`) из таблиц `customers` и `dealerships`. | Округлите `sales_amount` до целого числа. |
| **19** | Выведите список продуктов типа 'automobile' и дату их производства. | Найдите пересечение имен сотрудников и клиентов (тезки). | Если `street_address` содержит 'Apt', выведите 'Apartment', иначе 'House' (`CASE WHEN ... LIKE`). |
| **20** | Найдите клиентов, которые не получали писем (таблица `emails`, `LEFT JOIN`). | Выведите список всех `dealership_id` из таблицы `sales` и `salespeople` с удалением дублей. | Приведите `hire_date` сотрудников к формату 'YYYY-MM'. |
| **21** | Выведите продажи, где `sales_amount` меньше `base_msrp` продукта. | Объедините названия стран (`countries`) и названия городов (`top_cities_data`). | Создайте флаг `has_coordinates`: true, если lat/lon не NULL, иначе false. |
| **22** | Покажите сотрудников, работающих в штате 'TX'. | Выведите уникальные типы товаров (`product_type`). | Используйте `DISTINCT ON` для вывода последней продажи для каждого клиента. |
| **23** | Выведите клиентов и дату их последней покупки (через `JOIN` и `MAX` или `DISTINCT ON`). | Составьте список всех слов, используемых в названиях моделей. | Если `channel` продаж 'internet', скидка 5%, иначе 0%. Вывести сумму со скидкой. |
| **24** | Найдите дилеров, у которых нет продаж (используйте `LEFT JOIN`). | Выведите список всех численных ID (customer_id, product_id) в один столбец. | Замените пустые значения `email` на 'no_email@example.com'. |
| **25** | Выведите список скутеров, проданных клиентам-женщинам. | Выведите уникальные сочетания Город + Штат из таблицы `customers`. | Рассчитайте возраст клиента (приблизительно) на основе `date_added`, считая, что им было 18 при регистрации. |
| **26** | Соедините `sales`, `customers` и `dealerships` для полного отчета о продаже. | Объедините `username` сотрудников и первую часть email клиентов. | Присвойте категорию дилеру: 'Old' (открыт до 2000 г.), 'New' (после 2000 г.). |
| **27** | Выведите список писем, которые были отправлены, но отбиты (`bounced`). | Выведите список всех дат из таблицы `sales` (transaction) и `products` (production start). | Сравните `production_start_date` и `production_end_date`, выведите разницу в днях. |
| **28** | Найдите сотрудников, нанятых в том же году, когда открылся их дилерский центр. | Выведите уникальные суффиксы (`suffix`) клиентов. | Преобразуйте название модели в верхний регистр (`UPPER`). |
| **29** | Выведите продукты и количество дней, которое они производились. | Объедините имена клиентов из `customers` и `customers_nyc`. | Если сумма продажи равна 0, выведите 'Gift', иначе сумму. |
| **30** | Выведите клиентов, купивших 'Lemon Scooter', и дату покупки. | Выведите список всех `zip_code` из `public_transportation_by_zip` и `customers`. | Создайте поле `full_address` объединив адрес, город и штат через запятую. |

## 6. Требования к оформлению и сдаче

1.  **Репозиторий:**
    *   Работа выполняется в личном репозитории на GitHub.
    *   Создайте папку `lab_05`.
2.  **Файлы:**
    *   `README.md`. Отчет о выполнении. Должен содержать:
        *   Номер варианта.
        *   Текст 3-х индивидуальных заданий.
        *   SQL-код решений.
        *   **Скриншот результата** (первые 10-15 строк) из DBeaver/pgAdmin.
    *   `lab_05.sql`. Скрипт со всеми запросами подряд.
3.  **Сдача.** Ссылка на репозиторий в Moodle.
4.  **База данных:**
    *   Задания выполняются на основе дампа `bi_sql_data_student_dump.sql` (ссылка: [https://disk.yandex.ru/d/yJTa_s86xpbpMQ](https://disk.yandex.ru/d/yJTa_s86xpbpMQ)).

## 7. Критерии оценки

*   **5 баллов (Отлично).** Выполнены все общие и индивидуальные задания. Код работает верно, отчет содержит скриншоты и пояснения.
*   **4 балла (Хорошо).** Выполнены все задания, но есть мелкие ошибки в типах JOIN или сортировке. Отчет присутствует.
*   **3 балла (Удовлетворительно).** Выполнены только общие задания или индивидуальные задания с грубыми ошибками (использование декартова произведения вместо JOIN).
```