# Практическая работа 1. Геопространственный анализ данных. Аналитика с использованием сложных типов данных

**СУБД:** PostgreSQL  
**Источник данных:** `bi_sql_data_student_dump.sql`

---

## 1. Цель работы
Научиться применять продвинутые возможности PostgreSQL для анализа данных, выходящих за рамки стандартных чисел и строк. Освоить работу с временными рядами, геопространственными данными, массивами, JSON/JSONB структурами и полнотекстовым поиском.

## 2. Задачи
1.  **Анализ временных рядов.** Использование функций `DATE_TRUNC`, `EXTRACT`, `INTERVAL` для агрегации продаж по периодам.
2.  **Геопространственный анализ.** Установка расширений `cube` и `earthdistance`, расчет расстояний между клиентами и дилерскими центрами, поиск ближайших объектов.
3.  **Работа со сложными структурами.** Формирование и разбор массивов (`ARRAY`), генерация и запрос данных в формате `JSON/JSONB`.
4.  **Текстовая аналитика.** Токенизация текста, очистка от знаков препинания, частотный анализ слов в отзывах клиентов.

---

## 3. Теоретическая справка

### 3.1. Дата и время
PostgreSQL предоставляет мощные инструменты для работы с типом `TIMESTAMP`:
*   `DATE_TRUNC('part', date)` — усекает дату до указанной точности (год, месяц, час). Идеально для группировки.
*   `EXTRACT(part FROM date)` — извлекает часть даты (например, год или день недели).
*   `INTERVAL` — позволяет выполнять арифметические операции с датами (например, `date + INTERVAL '7 days'`).

### 3.2. Геопространственные данные
Для работы с координатами (широта/долгота) используются расширения:
*   **cube** и **earthdistance** — позволяют вычислять расстояния на поверхности Земли.
*   Функция `ll_to_earth(lat, long)` или `point(long, lat)` (в зависимости от подхода) используется для создания гео-точек.
*   Оператор `<@>` вычисляет расстояние в милях между точками.

### 3.3. JSON и Массивы
*   **JSONB** — бинарный формат JSON, поддерживающий индексацию и быстрый поиск.
    *   `->` — получить элемент JSON по ключу (возвращает JSON).
    *   `->>` — получить элемент по ключу в виде текста.
    *   `@>` — оператор вхождения (содержит ли JSON указанные ключи/значения).
*   **Массивы** — позволяют хранить списки значений в одной ячейке.
    *   `ARRAY_AGG()` — агрегатная функция для сбора значений в массив.
    *   `UNNEST()` — разворачивает массив обратно в строки.

---

## 4. Практическая часть (Разбор примеров)

*Выполните следующие примеры в своей базе данных, чтобы понять принцип работы.*

**Предварительная настройка:**
Для работы с геоданными выполните в SQL-консоли:
```sql
CREATE EXTENSION IF NOT EXISTS cube;
CREATE EXTENSION IF NOT EXISTS earthdistance;
```

### Пример 1. Анализ временных рядов
Рассчитаем количество продаж по месяцам за 2018 год.
```sql
SELECT 
    DATE_TRUNC('month', sales_transaction_date) AS month_date,
    COUNT(*) AS number_of_sales
FROM sales
WHERE EXTRACT(year FROM sales_transaction_date) = 2018
GROUP BY 1
ORDER BY 1;
```

### Пример 2. Геопространственный поиск
Найдем расстояние между клиентом (таблица `customers`) и дилером (таблица `dealerships`) в милях.

Примечание. Используется конструкция point(longitude, latitude).*

```sql
SELECT 
    c.customer_id, 
    d.dealership_id,
    point(c.longitude, c.latitude) <@> point(d.longitude, d.latitude) as distance_miles
FROM customers c
CROSS JOIN dealerships d
WHERE c.customer_id = 1 AND d.dealership_id = 1;
```

### Пример 3. Текстовая аналитика (отзывы)
Разберем отзыв на слова и очистим от знаков препинания.
```sql
SELECT 
    UNNEST(STRING_TO_ARRAY(
        REGEXP_REPLACE(feedback, '[^a-zA-Z]+', ' ', 'g'), 
    ' ')) AS word
FROM customer_survey
LIMIT 10;
```

### Пример 4. Поиск в JSONB
Выберем email из таблицы `customer_sales`, где в JSON-поле `customer_json` указан `customer_id = 20`.
```sql
SELECT customer_json ->> 'email' as email
FROM customer_sales
WHERE customer_json @> '{"customer_id": 20}';
```

---

## 5. Индивидуальные задания

Выберите **3 любых задания** из списка ниже и выполните их. Результат оформите в виде SQL-скрипта.

### Блок А. Анализ времени и Дат
1.  **Дни недели продаж.** Определите, в какой день недели (понедельник, вторник и т.д.) совершается наибольшее количество продаж (`sales`). Выведите день недели и количество транзакций.
2.  **Скорость реакции.** Рассчитайте среднее время (интервал), которое проходит между регистрацией клиента (`date_added` в `customers`) и его первой покупкой (`sales_transaction_date` в `sales`).
3.  **Квартальный отчет.** Выведите сумму продаж (`sales_amount`) с разбивкой по кварталам и годам (например, "2019 Q1").
4.  **«Спящие» клиенты.** Найдите клиентов, которые зарегистрировались более года назад (относительно текущей даты или фиксированной даты '2020-01-01'), но не совершили ни одной покупки за последние 6 месяцев этого периода.
5.  **Сезонность продуктов.** Для каждого типа продукта (`product_type`) определите месяц, в котором он продается лучше всего (максимальная сумма продаж).

### Блок Б. Геопространственный анализ
*(Требуется расширение earthdistance)*
6.  **Ближайший дилер.** Для каждого клиента из города 'New York City' найдите ближайший дилерский центр (`dealerships`) и расстояние до него.
7.  **Локальные продажи.** Посчитайте, какой процент продаж приходится на ситуации, когда клиент и дилерский центр находятся на расстоянии менее 50 миль друг от друга.
8.  **Покрытие дилеров.** Найдите дилерский центр, у которого наибольшее количество клиентов в радиусе 100 миль.
9.  **Изолированные клиенты.** Выведите список клиентов, у которых нет ни одного дилерского центра в радиусе 500 миль.
10. **География модели.** Для модели 'Model Chi' найдите среднюю широту и долготу покупателей (центроид продаж).

### Блок В. Сложные типы (Массивы и JSON)
11. **История покупок в JSON.** Создайте представление или запрос, который формирует JSON-объект для каждого клиента: `{ "id": 1, "name": "Ivan", "products": ["Car", "Scooter"] }`, используя агрегацию массивов.
12. **Поиск по атрибутам.** В таблице `customer_sales` (поле `customer_json`) найдите всех клиентов, у которых в JSON-структуре свойство `gender` равно 'F' и `title` не равно null.
13. **Агрегация в массив.** Сгруппируйте данные по штатам (`state`) и сформируйте массив email-адресов всех дилеров в этом штате.
14. **Извлечение из JSON.** Из таблицы `customer_sales` извлеките поле `sales` (массив внутри JSON), разверните его (`jsonb_array_elements`) и посчитайте общую сумму продаж, хранящуюся внутри JSON.
15. **Тэгирование.** Добавьте к таблице `customers` текстовое поле-массив `tags`. Напишите запрос, который добавляет тег 'VIP' всем клиентам, совершившим покупки на сумму более 50000.

### Блок Г. Текстовая аналитика
16. **Частотный словарь.** Составьте топ-10 самых часто встречающихся слов в таблице `customer_survey` (столбец `feedback`), исключив слова короче 3 символов.
17. **Поиск негатива.** Найдите все отзывы, содержащие слова с корнем 'bad', 'fail', 'poor' (используйте `to_tsvector` и `plainto_tsquery` или `ILIKE`).
18. **Категоризация.** Используя `CASE` и поиск подстрок, разделите отзывы на категории: 'Service' (если есть слова service, staff), 'Product' (bike, scooter, quality), 'Other'. Посчитайте количество отзывов в каждой категории.
19. **Сравнение длины.** Определите, есть ли корреляция между длиной отзыва (количество слов) и оценкой (`rating`). Выведите среднюю длину отзыва для каждой оценки.
20. **Уникальные слова.** Для конкретного клиента (выберите любой ID) выведите список всех уникальных слов, которые он использовал во всех своих отзывах (если отзывов несколько, объедините их).

---

## 6. Требования к оформлению

1.  **Репозиторий.** Работа выполняется в личном репозитории на GitHub.
2.  **Структура отчета (README.md):**
    *   Заголовок с темой работы и номером варианта/списком выбранных задач.
    *   **Задача 1.** Условие, SQL-код, Скриншот результата, Краткий вывод/пояснение.
    *   **Задача 2.** (аналогично).
    *   **Задача 3.** (аналогично).
3.  **Файлы:**
    *   `README.md` (основной отчет).
    *   `practical_work_01.sql` (файл со скриптами всех решенных задач).
4.  **Сдача.** В LMS Moodle прикрепляется ссылка на репозиторий.

## 7. Критерии оценки

*   **Зачтено:**
    *   Выбрано и решено не менее 3-х задач из разных блоков (рекомендуется) или одного блока.
    *   SQL-запросы корректны и возвращают ожидаемый результат.
    *   Присутствуют скриншоты подтверждения работы.
    *   Оформление соответствует требованиям.
*   **На доработку:**
    *   Решено менее 3-х задач.
    *   Отсутствуют скриншоты.
    *   Код не работает на предоставленном дампе БД.
    *   Использованы только простейшие `SELECT` без применения сложных типов данных (там, где это требовалось).