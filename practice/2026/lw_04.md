# Лабораторная работа №4. Оконные функции для анализа данных


**СУБД:** PostgreSQL  
**Источник данных:** `bi_sql_data_student_dump.sql`

## Цель работы
Изучить концепцию оконных функций в SQL и научиться применять их для выполнения сложных аналитических расчетов: ранжирования, вычисления скользящих средних, нарастающих итогов и сравнительного анализа строк без группировки данных.

## Задачи
1. Разобрать синтаксис оконных функций: предложение `OVER`, `PARTITION BY`, `ORDER BY` и `ROWS/RANGE`.
2. Научиться использовать функции ранжирования: `ROW_NUMBER()`, `RANK()`, `DENSE_RANK()`, `NTILE()`.
3. Освоить функции смещения для доступа к предыдущим и следующим строкам: `LAG()`, `LEAD()`.
4. Применить агрегатные функции в качестве оконных для вычисления накопительных итогов и скользящих статистик.

## Теоретическая часть

**Оконные функции** позволяют выполнять вычисления для набора строк, связанных с текущей строкой. В отличие от обычных агрегатных функций (`SUM`, `AVG`, `COUNT`), использование которых с `GROUP BY` приводит к схлопыванию строк до одной на группу, оконные функции сохраняют все исходные строки результата, добавляя к ним вычисляемое значение.

### Базовый синтаксис
```sql
SELECT {columns},
       {window_func} OVER (PARTITION BY {partition_key} ORDER BY {order_key} {frame_clause})
FROM table1;
```

*   **`OVER()`**. Определяет, что функция является оконной.
*   **`PARTITION BY`**. Разделяет набор данных на группы (окна), внутри которых производятся вычисления (аналог `GROUP BY`, но без свертки строк). Если не указано, окном считается весь набор данных.
*   **`ORDER BY`**. Определяет порядок строк внутри окна (важно для ранжирования и накопительных итогов).
*   **Window Frame (`ROWS ...`)**. Уточняет набор строк относительно текущей строки (например, «3 строки до текущей»).

### Основные типы функций

1.  **Функции ранжирования:**
    *   `ROW_NUMBER()`. Возвращает уникальный номер строки (1, 2, 3...).
    *   `RANK()`. Присваивает ранг. Если значения равны, ранги одинаковы, а следующий пропускается (1, 1, 3...).
    *   `DENSE_RANK()`. Присваивает ранг. Если значения равны, ранги одинаковы, следующий не пропускается (1, 1, 2...).
    *   `NTILE(n)`. Разбивает отсортированные строки на `n` примерно равных групп (бакетов).

2.  **Функции смещения:**
    *   `LAG(col, offset)`. Возвращает значение столбца `col` из строки, находящейся на `offset` позиций *перед* текущей.
    *   `LEAD(col, offset)`. Возвращает значение столбца `col` из строки, находящейся на `offset` позиций *после* текущей.

3.  **Агрегатные функции в оконном режиме:**
    *   `SUM()`, `AVG()`, `MIN()`, `MAX()`, `COUNT()` могут использоваться с `OVER()` для вычисления нарастающего итога или скользящего среднего.

### Оконный фрейм (Window Frame)
Используется для точного определения границ окна.
Пример: `ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING` (включает предыдущую, текущую и следующую строки).

## Практическая часть (Общие задания)

Для выполнения заданий необходимо развернуть базу данных из дампа `bi_sql_data_student_dump.sql`.

### Задание 4.1. Ранжирование сотрудников по стажу
**Задача.** Менеджмент хочет оценить сотрудников (`salespeople`) в каждом дилерском центре на основе даты их найма.
**Решение:**

```sql
SELECT salesperson_id, dealership_id, first_name, hire_date,
       RANK() OVER (PARTITION BY dealership_id ORDER BY hire_date) as hire_rank
FROM salespeople
WHERE termination_date IS NULL;
```

### Задание 4.2. Анализ динамики заполнения адресов
**Задача.** Посмотреть накопительный итог (Running Total) количества клиентов, заполнивших поле `street_address`, в разбивке по датам регистрации.
**Решение:**

```sql
SELECT date_added::DATE,
       COUNT(CASE WHEN street_address IS NOT NULL THEN 1 END) 
       OVER (ORDER BY date_added::DATE) as total_addresses_filled
FROM customers
ORDER BY date_added::DATE
LIMIT 50;
```

### Задание 4.3. Скользящее среднее продаж (7 дней)
**Задача.** Рассчитать 7-дневное скользящее среднее суммы продаж.
**Решение:**

```sql
WITH daily_sales AS (
    SELECT sales_transaction_date::DATE as sale_date,
           SUM(sales_amount) as daily_sum
    FROM sales
    GROUP BY 1
)
SELECT sale_date, daily_sum,
       AVG(daily_sum) OVER (ORDER BY sale_date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) as moving_avg_7_days
FROM daily_sales
ORDER BY sale_date;
```

## Индивидуальные задания

Выберите вариант задания в соответствии с вашим номером в списке группы.

| Вариант | Задание 1: Ранжирование (RANK, DENSE_RANK, ROW_NUMBER) | Задание 2: Смещение и сравнение (LAG, LEAD, NTILE) | Задание 3: Агрегация с окном (Нарастающий итог, Скользящее среднее) |
| :--- | :--- | :--- | :--- |
| **1** | Ранжировать продукты (`products`) по цене (`base_msrp`) от дорогих к дешевым внутри каждого типа (`product_type`). | Для каждого клиента вывести дату добавления и дату добавления *предыдущего* зарегистрированного клиента (`LAG`) в том же штате. | Рассчитать нарастающий итог продаж (`sales_amount`) по дням для дилера с `dealership_id = 10`. |
| **2** | Пронумеровать (`ROW_NUMBER`) продажи (`sales`) для каждого клиента, упорядочив их по дате транзакции (от новых к старым). | Сравнить цену текущего товара с ценой *следующего* по дороговизне товара того же типа (`LEAD` по `base_msrp`). | Вычислить средний чек (`AVG(sales_amount)`) накопительным итогом для каждого канала продаж (`channel`). |
| **3** | Найти топ-3 самых дорогих товара (`rank <= 3`) в каждой товарной категории (`product_type`). | Разбить всех клиентов на 4 группы (`NTILE`) в зависимости от их широты (`latitude`) — от севера к югу. | Рассчитать скользящую сумму продаж (3 дня: вчера, сегодня, завтра) для всей компании. |
| **4** | Ранжировать дилеров (`dealerships`) по дате открытия внутри каждого штата. | Для каждой продажи найти разницу в сумме с *предыдущей* продажей того же сотрудника (используйте `LAG` в таблице `sales`). | Нарастающий итог количества отправленных писем (`emails`) по датам (`sent_date`). |
| **5** | Присвоить ранг сотрудникам (`salespeople`) по длительности работы внутри дилерского центра. | Вывести список товаров и цену *предыдущего* по алфавиту товара (`LAG` по `model`). | Скользящее среднее цены (`base_msrp`) продуктов, упорядоченных по году выпуска (окно: текущий + 2 предыдущих). |
| **6** | Пронумеровать уникальных клиентов в таблице `sales` по сумме их покупок (от большей к меньшей). | Сравнить дату найма сотрудника с датой найма *следующего* принятого сотрудника в том же дилерском центре. | Нарастающий итог продаж (`sales_amount`) отдельно для каждого типа продукта (`product_type`, нужен JOIN). |
| **7** | Ранжировать клиентов (`customers`) по алфавиту имени (`first_name`) внутри каждого штата (`state`). | Разделить все продукты на 10 ценовых категорий (`NTILE`) на основе `base_msrp`. | Рассчитать минимум и максимум продаж (`sales_amount`) в скользящем окне (5 последних транзакций) для каждого дилера. |
| **8** | Найти самые старые дилерские центры (`RANK` по `date_opened`) в каждом городе. | Вычислить разницу в днях между текущим и *предыдущим* письмом (`emails`), отправленным одному и тому же клиенту. | Нарастающий итог количества нанятых сотрудников (`salespeople`) по месяцам найма. |
| **9** | Ранжировать продажи (`sales`) по сумме внутри каждого канала (`channel`). | Вывести дату транзакции и дату *следующей* транзакции для каждого клиента. | Скользящее среднее продаж (по 3 транзакции) для каждого продукта. |
| **10** | Пронумеровать продукты по году выпуска (`year`) от новых к старым внутри типа продукта. | Сравнить `base_msrp` товара со средней ценой *предыдущих двух* товаров того же типа. | Нарастающий итог суммы продаж для клиентов из штата 'CA' (требуется JOIN). |
| **11** | Ранжировать клиентов по длине их фамилии (`LENGTH(last_name)`) внутри каждого города. | Разделить сотрудников на 3 группы (`NTILE`) по дате найма. | Накопительная сумма продаж (`sales_amount`) по дням только для канала 'internet'. |
| **12** | Присвоить `DENSE_RANK` продуктам по цене (`base_msrp`) без учета типа. | Найти отклонение цены товара от цены *предыдущего* товара в общем списке (сортировка по цене). | Скользящее количество открытых писем (`emails`) по дням (окно: 7 дней). |
| **13** | Пронумеровать все дилерские центры по географической долготе (`longitude`) с запада на восток. | Для каждой продажи вывести сумму продажи и сумму *следующей* продажи в этом же дилерском центре. | Нарастающий итог выплаченных бонусов (предположим 10% от `sales_amount`) для каждого продавца. |
| **14** | Ранжировать сотрудников по фамилии внутри гендерных групп (`gender`). | Вычислить прирост продаж (`sales_amount` - `LAG(sales_amount)`) по дням. | Средняя цена (`base_msrp`) продуктов накопительным итогом при сортировке по дате начала производства. |
| **15** | Найти 5 самых последних зарегистрированных клиентов (`ROW_NUMBER` по `date_added`) в каждом штате. | Разделить продажи на 5 групп (`NTILE`) по величине суммы сделки. | Скользящее среднее продаж (за 10 последних транзакций) для дилера с `dealership_id = 1`. |
| **16** | Ранжировать типы продуктов по средней цене (сначала подзапрос/CTE с группировкой, потом ранг). | Сравнить широту (`latitude`) клиента с широтой *следующего* клиента в списке, отсортированном по ID. | Нарастающий итог количества клиентов, у которых `gender = 'F'`, по дате добавления. |
| **17** | Пронумеровать письма (`emails`) для каждого клиента по дате отправки. | Вывести разницу в датах открытия (`date_opened`) дилерских центров внутри одного штата (используя `LAG`). | Максимальная цена продажи в скользящем окне (текущая и 4 предыдущих) для каждого продукта. |
| **18** | Ранжировать продукты по названию модели (`model`) внутри года выпуска (`year`). | Для каждого сотрудника вывести имя *предыдущего* нанятого сотрудника в компании. | Нарастающий итог продаж автомобилей (тип 'automobile') по месяцам. |
| **19** | Присвоить ранг продажам по сумме. Если суммы равны — ранги должны идти подряд (`DENSE_RANK`). | Разделить клиентов на 2 группы (`NTILE`) по дате регистрации: "Старые" и "Новые". | Скользящее среднее значение широты (`latitude`) последних 5 добавленных клиентов. |
| **20** | Ранжировать города (`top_cities_data`) по количеству клиентов (`number_of_customers`). | Найти продажи, сумма которых меньше суммы *предыдущей* продажи этого же товара (`LAG`). | Накопительная сумма площади (условно `sales_amount`) проданных товаров по каналам. |
| **21** | Пронумеровать сотрудников, у которых не указана дата увольнения, по `salesperson_id`. | Для каждого письма показать тему текущего и тему *следующего* письма клиенту. | Скользящий подсчет количества продаж (`COUNT`) за последние 3 дня по каждому дилеру. |
| **22** | Ранжировать продукты по длительности производства (`production_end_date` - `production_start_date`). | Вычислить % изменения цены (`base_msrp`) относительно *предыдущего* по цене товара в категории. | Нарастающий итог продаж для продавцов-женщин (`gender='Female'`, нужен JOIN). |
| **23** | Найти самую первую продажу (`ROW_NUMBER` = 1) для каждого товара (`product_id`). | Разделить дилеров на 4 квартиля (`NTILE`) по дате открытия. | Средняя сумма продажи накопительным итогом по дням недели (Mon, Tue...). |
| **24** | Ранжировать клиентов по почтовому индексу (`postal_code`) внутри города. | Вывести `ip_address` текущего клиента и *предыдущего* клиента (сортировка по ID). | Нарастающий итог количества товаров, снятых с производства (`production_end_date` not null), по годам. |
| **25** | Присвоить ранг письмам по дате клика (`clicked_date`), игнорируя пустые значения. | Сравнить сумму продажи с *следующей* продажей по каналу 'internet'. | Скользящее среднее `sales_amount` с окном "1 preceding, 1 following" для сглаживания графика. |
| **26** | Ранжировать продукты типа 'scooter' по цене. | Для каждого дилера показать дату закрытия и дату закрытия *следующего* закрывшегося дилера. | Накопительный итог количества клиентов без телефона (`phone is null`) по дате регистрации. |
| **27** | Пронумеровать продажи каждого дня по времени транзакции. | Разделить продукты на 3 ценовые категории (`NTILE`) внутри каждого года выпуска. | Сумма продаж накопительным итогом, сбрасывая итог каждый месяц (`PARTITION BY` год-месяц). |
| **28** | Ранжировать сотрудников по имени (`first_name`) в обратном алфавитном порядке. | Найти разницу в `distance` (таблица `closest_dealerships`) между текущей и *следующей* записью для клиента. | Скользящее среднее продаж за 7 дней только для города 'New York' (нужен JOIN). |
| **29** | Найти топ-10 самых дорогих продаж (`RANK`) за 2018 год. | Вывести модель товара и модель *предыдущего* товара, выпущенного в том же году (`LAG` по дате запуска). | Нарастающий итог количества уникальных клиентов, совершивших покупку, по датам. |
| **30** | Ранжировать штаты по количеству дилерских центров. | Сравнить дату добавления клиента с датой добавления *предыдущего* клиента с тем же именем (`first_name`). | Скользящая сумма `base_msrp` всех доступных продуктов, упорядоченных по ID. |

## Требования к оформлению и сдаче

1.  **Репозиторий:**
    *   Создайте папку `lab_04` в вашем личном репозитории на GitHub.
2.  **Файлы:**
    *   `README.md`. Отчет о выполнении. 
    Должен содержать:
        *   Номер варианта.
        *   Текст 3-х индивидуальных заданий.
        *   SQL-код решений.
        *   **Скриншоты результатов** (первые 10-15 строк) из DBeaver/pgAdmin.
    *   `lab_04.sql`: Скрипт со всеми запросами подряд.
3.  **Сдача.** Ссылка на репозиторий в Moodle.

## 7. Критерии оценки

*   **5 баллов (Отлично).** Выполнены все общие и индивидуальные задания. Код работает верно, отчет содержит скриншоты и пояснения.
*   **4 балла (Хорошо).** Выполнены все задания, но есть мелкие ошибки в границах окон или сортировке. Отчет присутствует.
*   **3 балла (Удовлетворительно).** Выполнены только общие задания или индивидуальные задания с грубыми ошибками (использование GROUP BY вместо Window Functions).
```