# Лабораторная работа №4. Оконные функции для анализа данных


**СУБД:** PostgreSQL  
**Источник данных:** `bi_sql_data_student_dump.sql`

## Цель работы
Изучить концепцию оконных функций в SQL и научиться применять их для выполнения сложных аналитических расчетов: ранжирования, вычисления скользящих средних, нарастающих итогов и сравнительного анализа строк без группировки данных.

## Задачи
1. Разобрать синтаксис оконных функций: предложение `OVER`, `PARTITION BY`, `ORDER BY` и `ROWS/RANGE`.
2. Научиться использовать функции ранжирования: `ROW_NUMBER()`, `RANK()`, `DENSE_RANK()`, `NTILE()`.
3. Освоить функции смещения для доступа к предыдущим и следующим строкам: `LAG()`, `LEAD()`.
4. Применить агрегатные функции в качестве оконных для вычисления накопительных итогов и скользящих статистик.

## Теоретическая часть

**Оконные функции** позволяют выполнять вычисления для набора строк, связанных с текущей строкой. В отличие от обычных агрегатных функций (`SUM`, `AVG`, `COUNT`), использование которых с `GROUP BY` приводит к схлопыванию строк до одной на группу, оконные функции сохраняют все исходные строки результата, добавляя к ним вычисляемое значение.

### Базовый синтаксис
```sql
SELECT {columns},
       {window_func} OVER (PARTITION BY {partition_key} ORDER BY {order_key} {frame_clause})
FROM table1;
```

*   **`OVER()`**. Определяет, что функция является оконной.
*   **`PARTITION BY`**. Разделяет набор данных на группы (окна), внутри которых производятся вычисления (аналог `GROUP BY`, но без свертки строк). Если не указано, окном считается весь набор данных.
*   **`ORDER BY`**. Определяет порядок строк внутри окна (важно для ранжирования и накопительных итогов).
*   **Window Frame (`ROWS ...`)**. Уточняет набор строк относительно текущей строки (например, «3 строки до текущей»).

### Основные типы функций

1.  **Функции ранжирования:**
    *   `ROW_NUMBER()`. Возвращает уникальный номер строки (1, 2, 3...).
    *   `RANK()`. Присваивает ранг. Если значения равны, ранги одинаковы, а следующий пропускается (1, 1, 3...).
    *   `DENSE_RANK()`. Присваивает ранг. Если значения равны, ранги одинаковы, следующий не пропускается (1, 1, 2...).
    *   `NTILE(n)`. Разбивает отсортированные строки на `n` примерно равных групп (бакетов).

2.  **Функции смещения:**
    *   `LAG(col, offset)`. Возвращает значение столбца `col` из строки, находящейся на `offset` позиций *перед* текущей.
    *   `LEAD(col, offset)`. Возвращает значение столбца `col` из строки, находящейся на `offset` позиций *после* текущей.

3.  **Агрегатные функции в оконном режиме:**
    *   `SUM()`, `AVG()`, `MIN()`, `MAX()`, `COUNT()` могут использоваться с `OVER()` для вычисления нарастающего итога или скользящего среднего.

### Оконный фрейм (Window Frame)
Используется для точного определения границ окна.
Пример: `ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING` (включает предыдущую, текущую и следующую строки).

## Практическая часть (Общие задания)

Для выполнения заданий необходимо развернуть базу данных из дампа `bi_sql_data_student_dump.sql`.

### Задание 4.1. Ранжирование сотрудников по стажу
**Задача.** Менеджмент хочет оценить сотрудников (`salespeople`) в каждом дилерском центре на основе даты их найма.

**Решение:**

```sql
SELECT salesperson_id, dealership_id, first_name, hire_date,
       RANK() OVER (PARTITION BY dealership_id ORDER BY hire_date) as hire_rank
FROM salespeople
WHERE termination_date IS NULL;
```

### Задание 4.2. Анализ динамики заполнения адресов
**Задача.** Посмотреть накопительный итог (Running Total) количества клиентов, заполнивших поле `street_address`, в разбивке по датам регистрации.

**Решение:**

```sql
SELECT date_added::DATE,
       COUNT(CASE WHEN street_address IS NOT NULL THEN 1 END) 
       OVER (ORDER BY date_added::DATE) as total_addresses_filled
FROM customers
ORDER BY date_added::DATE
LIMIT 50;
```

### Задание 4.3. Скользящее среднее продаж (7 дней)
**Задача.** Рассчитать 7-дневное скользящее среднее суммы продаж.

**Решение:**

```sql
WITH daily_sales AS (
    SELECT sales_transaction_date::DATE as sale_date,
           SUM(sales_amount) as daily_sum
    FROM sales
    GROUP BY 1
)
SELECT sale_date, daily_sum,
       AVG(daily_sum) OVER (ORDER BY sale_date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) as moving_avg_7_days
FROM daily_sales
ORDER BY sale_date;
```

## Индивидуальные задания

[Варианты заданий на образовательном портале](https://envlab.ru/mod/assign/view.php?id=1052)

## Требования к оформлению и сдаче

1.  **Репозиторий:**
    *   Создайте папку `lab_04` в вашем личном репозитории на GitHub.
2.  **Файлы:**
    *   `README.md`. Отчет о выполнении. 
    Должен содержать:
        *   Номер варианта.
        *   Текст 3-х индивидуальных заданий.
        *   SQL-код решений.
        *   **Скриншоты результатов** (первые 10-15 строк) из DBeaver/pgAdmin.
    *   `lab_04.sql`. Скрипт со всеми запросами подряд.
3.  **Сдача.** Ссылка на репозиторий в Moodle.

## 7. Критерии оценки

*   **5 баллов (Отлично).** Выполнены все общие и индивидуальные задания. Код работает верно, отчет содержит скриншоты и пояснения.
*   **4 балла (Хорошо).** Выполнены все задания, но есть мелкие ошибки в границах окон или сортировке. Отчет присутствует.
*   **3 балла (Удовлетворительно).** Выполнены только общие задания или индивидуальные задания с грубыми ошибками (использование GROUP BY вместо Window Functions).

```
