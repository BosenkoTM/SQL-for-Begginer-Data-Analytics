# Лабораторная работа №3. Агрегации и аналитические функции в SQL

**СУБД:** PostgreSQL  

---

## Цель работы
Научиться выполнять быстрый и эффективный анализ данных, используя возможности агрегирования SQL. Освоить синтаксис группировки данных, фильтрации групп и вычисления статистических показателей.

## Задачи
1.  **Изучить теоретические основы** агрегации данных (функции `COUNT`, `SUM`, `AVG`, `MIN`, `MAX`, `STDDEV`).
2.  **Разобрать принципы работы** предложения `GROUP BY` для разделения данных на логические группы.
3.  **Научиться фильтровать** агрегированные данные с помощью предложения `HAVING`.
4.  **Применить полученные знания** для анализа качества данных (поиск пропусков, дубликатов).
5.  **Выполнить индивидуальное задание** (3 запроса) согласно варианту.

---

## Теоретическая часть

### Агрегатные функции
Агрегатные функции принимают на вход набор строк (значения столбца) и возвращают одно итоговое значение. Это основной инструмент аналитика для получения сводной статистики.

**Основные функции (PostgreSQL):**

*   `COUNT(*)` — Считает общее количество строк в выборке (включая NULL).
*   `COUNT(column)` — Считает количество строк, где значение в столбце **не** равно NULL.
*   `COUNT(DISTINCT column)` — Считает количество **уникальных** значений в столбце.
*   `SUM(column)` — Вычисляет сумму значений (только для числовых типов).
*   `AVG(column)` — Вычисляет среднее арифметическое.
    > **Важно:** В PostgreSQL деление целых чисел дает целое число. Для точного результата используйте приведение типов: `AVG(column::FLOAT)` или `AVG(CAST(column AS FLOAT))`.
*   `MIN(column)` / `MAX(column)` — Возвращают минимальное и максимальное значения.
*   `STDDEV(column)` — Вычисляет стандартное отклонение (показатель разброса данных относительно среднего).

### Группировка данных (GROUP BY)
Предложение `GROUP BY` позволяет разделить данные на подмножества (группы) по значению одного или нескольких столбцов. Агрегатные функции затем применяются к каждой группе отдельно.

**Синтаксис:**
```sql
SELECT column_name, AGG_FUNC(value_column)
FROM table_name
GROUP BY column_name;
```

**Логика работы:**
1.  СУБД находит все уникальные значения в столбце, указанном в `GROUP BY`.
2.  Строки распределяются по этим группам.
3.  Агрегатная функция вычисляется для каждой группы изолированно.

### Фильтрация групп (HAVING)
Критически важно различать `WHERE` и `HAVING`:

*   **`WHERE`**: Фильтрует строки **до** группировки. Здесь нельзя использовать результаты агрегатных функций (например, `count(*)`).
*   **`HAVING`**: Фильтрует результаты **после** группировки. Здесь условия строятся на результатах агрегатов.

**Пример:**
*Неверно:* `SELECT state FROM customers WHERE COUNT(*) > 1000`
*Верно:*
```sql
SELECT state, COUNT(*)
FROM customers
GROUP BY state
HAVING COUNT(*) > 1000;
```

### Аналитические функции (Ordered Set Aggregates)
Для вычисления медианы и процентилей в PostgreSQL используется синтаксис `WITHIN GROUP`.

*   **Медиана:** `PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY column)`
*   **Мода:** `MODE() WITHIN GROUP (ORDER BY column)`

---

## Практическая часть

### Подготовка
Работу выполнять на основе дампа базы данных `bi_sql_data_student_dump.sql` (использовался в ЛР №1). Схема содержит таблицы:
*   `products` (товары)
*   `customers` (клиенты)
*   `sales` (продажи)
*   `dealerships` (дилерские центры)

### Пример выполнения запроса
**Задача.** Найти типы продуктов (`product_type`), средняя базовая цена (`base_msrp`) которых превышает 500 у.е., и отсортировать их по убыванию средней цены.

**SQL Запрос:**
```sql
SELECT 
    product_type,
    ROUND(AVG(base_msrp), 2) as avg_price
FROM products
GROUP BY product_type
HAVING AVG(base_msrp) > 500
ORDER BY avg_price DESC;
```

---

## Индивидуальные задания

Выберите вариант согласно списку группы. Результат каждого задания должен быть оформлен в виде SQL-запроса и скриншота/таблицы с результатом.

| Вариант | Задание 1 (Базовые агрегаты) | Задание 2 (Группировка GROUP BY) | Задание 3 (Фильтрация HAVING и Аналитика) |
|:---:|:---|:---|:---|
| **1** | Найти мин., макс. и среднюю цену (`base_msrp`) всех продуктов. | Посчитать количество клиентов (`customer_id`) для каждого пола (`gender`). | Вывести штаты (`state`), где суммарные продажи (`sales_amount`) превышают 10,000. |
| **2** | Посчитать общее количество записей в таблице `sales`. | Вычислить среднюю цену продукта для каждого типа (`product_type`). | Найти `dealership_id`, совершивших более 100 продаж. |
| **3** | Найти стандартное отклонение (`STDDEV`) цены продуктов. | Посчитать количество уникальных клиентов в каждом штате. | Вывести типы продуктов, максимальная цена которых меньше 1000. |
| **4** | Найти самую раннюю и самую позднюю дату продажи в `sales`. | Посчитать сумму продаж (`sales_amount`) по каждому каналу (`channel`). | Показать штаты, в которых зарегистрировано более 500 женщин-клиентов. |
| **5** | Вычислить общую выручку (сумма `sales_amount`) за всё время. | Найти средний возраст (или год рождения) клиентов по штатам. | Вывести `product_id`, проданные более 50 раз. |
| **6** | Посчитать сколько типов продуктов представлено в таблице. | Вывести минимальную цену товара для каждой категории (`product_type`). | Найти города дилеров, где средний чек выше 500. |
| **7** | Найти среднюю цену (`base_msrp`) только для скутеров (`'scooter'`). | Посчитать количество транзакций продаж для каждого `dealership_id`. | Вывести каналы продаж, где максимальная сумма продажи > 15,000. |
| **8** | Найти максимальную сумму одной продажи в таблице `sales`. | Посчитать количество продуктов каждого типа. | Вывести `customer_id` клиентов, совершивших более 5 покупок. |
| **9** | Посчитать количество клиентов без указанного штата (`state` IS NULL). | Вычислить суммарную выручку по каждой дате продажи. | Найти типы продуктов, средняя цена которых от 500 до 5000. |
| **10** | Найти дисперсию (`VAR_SAMP`) цены продуктов. | Посчитать количество дилеров в каждом штате. | Вывести штаты, где суммарная выручка превысила 1,000,000. |
| **11** | Посчитать уникальные проданные продукты (из таблицы `sales`). | Найти максимальную цену продажи по каждому `dealership_id`. | Вывести `product_type` со стандартным отклонением цены > 50. |
| **12** | Найти среднюю сумму продажи (округлить до 2 знаков). | Посчитать распределение клиентов по полу в каждом штате. | Найти даты, в которые было совершено менее 10 продаж. |
| **13** | Найти суммарный `base_msrp` всех продуктов типа `'automobile'`. | Вычислить среднюю сумму чека для каждого клиента. | Вывести `dealership_id`, продавших более 10 уникальных продуктов. |
| **14** | Посчитать % пропусков в поле `street_address` (через CASE). | Посчитать общую выручку для каждого типа продукта. | Найти штаты, где минимальная сумма продажи была выше 100. |
| **15** | Найти количество клиентов из штата `'CA'`. | Вывести количество продаж по годам (функция `EXTRACT`). | Вывести категории товаров, в которых представлено более 5 моделей. |
| **16** | Найти разницу между самой дорогой и дешевой машиной. | Посчитать среднюю цену продуктов для каждого года выпуска. | Найти клиентов, чья суммарная сумма покупок > 20,000. |
| **17** | Вычислить общее количество проданных единиц товара. | Сгруппировать продажи по `channel` и `dealership_id` (сумма). | Вывести штаты, где клиентов-мужчин больше 100. |
| **18** | Найти медианную цену продукта (`PERCENTILE_CONT(0.5)`). | Посчитать количество продаж для каждого `product_id`. | Вывести дни, когда общая сумма продаж была < 100. |
| **19** | Посчитать количество уникальных штатов в `dealerships`. | Найти мин. и макс. сумму продажи для каждого канала. | Вывести `product_type`, где средняя цена > 10,000 и < 50,000. |
| **20** | Найти сумму всех `base_msrp`. | Посчитать клиентов с одинаковыми именами (`first_name`). | Найти дилеров, которые совершили менее 5 продаж. |
| **21** | Найти среднеквадратичное отклонение продаж. | Сгруппировать продукты по первой букве типа, найти среднюю цену. | Вывести штаты, где разница между max и min продажей > 1000. |
| **22** | Посчитать количество продаж с суммой > 500. | Вывести топ-5 дат с наибольшим количеством продаж. | Вывести `dealership_id`, где средняя сумма продажи < 500. |
| **23** | Найти максимальный `customer_id`. | Посчитать суммарную `base_msrp` по типам продуктов. | Найти типы продуктов, купленные клиентами из > 3 штатов. |
| **24** | Вычислить среднюю цену товара с учетом НДС (*1.2). | Сгруппировать продажи по месяцам (`EXTRACT`) и найти сумму. | Вывести месяцы, в которых продаж было больше 100. |
| **25** | Посчитать количество NULL в поле `suffix` клиентов. | Найти максимальный `sales_amount` для каждого клиента. | Вывести `product_id`, проданные ровно 1 раз. |
| **26** | Найти сумму продаж за 2018 год. | Посчитать количество дилеров в каждом регионе. | Вывести штаты, где средний возраст клиентов < 30 лет. |
| **27** | Найти отношение макс. цены к минимальной (таблица `products`). | Сгруппировать клиентов по штату и полу (количество). | Вывести группы (штат, пол), где количество людей < 10. |
| **28** | Посчитать записи с уникальным `email` в таблице клиентов. | Вычислить средний `sales_amount` по каждому дилеру. | Найти дилеров с суммой продаж выше 500,000. |
| **29** | Найти моду (самое частое значение) для `product_type`. | Посчитать общую стоимость всех товаров по типам. | Вывести `channel` продаж с количеством заказов < 50. |
| **30** | Посчитать клиентов с обращением 'Mr.' или 'Mrs.'. | Найти минимальную дату продажи для каждого продукта. | Вывести `dealership_id` с продажами на сумму более 1 млн. |

---

## Правила оформления и сдачи

1.  **Репозиторий:**
    *   Создать (или продолжить использовать) репозиторий на GitHub/GitLab.
    *   В репозитории создать директорию `lab_3`.
2.  **Структура отчета:**
    *   Файл `README.md`:
        *   Текст задания вашего варианта.
        *   Описание хода работы.
        *   Код SQL-запросов и скриншоты результатов (или таблицы в Markdown).
        *   **Выводы** (анализ полученных данных).
    *   Файл `queries.sql`:
        *   Чистый SQL-код решений с комментариями.
3.  **Сдача работы:**
    *   В Moodle прикрепить **только ссылку** на репозиторий.

## Критерии оценки

*   **5 баллов.** Выполнены все 3 задания, код оптимален, `README.md` содержит полные выводы и скриншоты.
*   **4 балла.** Задания выполнены, но есть мелкие замечания по стилю кода или оформлению отчета.
*   **3 балла.** Выполнено 2 задания из 3, либо допущены ошибки в логике `HAVING`/`GROUP BY`.
*   **0-2 балла.** Задания не выполнены или код не работает.

```
