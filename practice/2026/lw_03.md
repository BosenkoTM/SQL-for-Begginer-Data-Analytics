# Лабораторная работа №3. Агрегации и аналитические функции в SQL

**СУБД:** PostgreSQL  

---

## Цель работы
Научиться выполнять быстрый и эффективный анализ данных, используя возможности агрегирования SQL. Освоить синтаксис группировки данных, фильтрации групп и вычисления статистических показателей.

## Задачи
1.  **Изучить теоретические основы** агрегации данных (функции `COUNT`, `SUM`, `AVG`, `MIN`, `MAX`, `STDDEV`).
2.  **Разобрать принципы работы** предложения `GROUP BY` для разделения данных на логические группы.
3.  **Научиться фильтровать** агрегированные данные с помощью предложения `HAVING`.
4.  **Применить полученные знания** для анализа качества данных (поиск пропусков, дубликатов).
5.  **Выполнить индивидуальное задание** (3 запроса) согласно варианту.

---

## Теоретическая часть

### Агрегатные функции
Агрегатные функции принимают на вход набор строк (значения столбца) и возвращают одно итоговое значение. Это основной инструмент аналитика для получения сводной статистики.

**Основные функции (PostgreSQL):**

*   `COUNT(*)` — Считает общее количество строк в выборке (включая NULL).
*   `COUNT(column)` — Считает количество строк, где значение в столбце **не** равно NULL.
*   `COUNT(DISTINCT column)` — Считает количество **уникальных** значений в столбце.
*   `SUM(column)` — Вычисляет сумму значений (только для числовых типов).
*   `AVG(column)` — Вычисляет среднее арифметическое.
    > **Важно:** В PostgreSQL деление целых чисел дает целое число. Для точного результата используйте приведение типов: `AVG(column::FLOAT)` или `AVG(CAST(column AS FLOAT))`.
*   `MIN(column)` / `MAX(column)` — Возвращают минимальное и максимальное значения.
*   `STDDEV(column)` — Вычисляет стандартное отклонение (показатель разброса данных относительно среднего).

### Группировка данных (GROUP BY)
Предложение `GROUP BY` позволяет разделить данные на подмножества (группы) по значению одного или нескольких столбцов. Агрегатные функции затем применяются к каждой группе отдельно.

**Синтаксис:**
```sql
SELECT column_name, AGG_FUNC(value_column)
FROM table_name
GROUP BY column_name;
```

**Логика работы:**
1.  СУБД находит все уникальные значения в столбце, указанном в `GROUP BY`.
2.  Строки распределяются по этим группам.
3.  Агрегатная функция вычисляется для каждой группы изолированно.

### Фильтрация групп (HAVING)
Критически важно различать `WHERE` и `HAVING`:

*   **`WHERE`**: Фильтрует строки **до** группировки. Здесь нельзя использовать результаты агрегатных функций (например, `count(*)`).
*   **`HAVING`**: Фильтрует результаты **после** группировки. Здесь условия строятся на результатах агрегатов.

**Пример:**
*Неверно:* `SELECT state FROM customers WHERE COUNT(*) > 1000`
*Верно:*
```sql
SELECT state, COUNT(*)
FROM customers
GROUP BY state
HAVING COUNT(*) > 1000;
```

### Аналитические функции (Ordered Set Aggregates)
Для вычисления медианы и процентилей в PostgreSQL используется синтаксис `WITHIN GROUP`.

*   **Медиана:** `PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY column)`
*   **Мода:** `MODE() WITHIN GROUP (ORDER BY column)`

---

## Практическая часть

### Подготовка
Работу выполнять на основе дампа базы данных `bi_sql_data_student_dump.sql` (использовался в ЛР №1). Схема содержит таблицы:
*   `products` (товары)
*   `customers` (клиенты)
*   `sales` (продажи)
*   `dealerships` (дилерские центры)

### Пример выполнения запроса
**Задача.** Найти типы продуктов (`product_type`), средняя базовая цена (`base_msrp`) которых превышает 500 у.е., и отсортировать их по убыванию средней цены.

**SQL Запрос:**
```sql
SELECT 
    product_type,
    ROUND(AVG(base_msrp), 2) as avg_price
FROM products
GROUP BY product_type
HAVING AVG(base_msrp) > 500
ORDER BY avg_price DESC;
```

---

## Индивидуальные задания

[Варианты заданий на образовательном портале](https://envlab.ru/mod/assign/view.php?id=1047)

---

## Правила оформления и сдачи

1.  **Репозиторий:**
    *   Создать (или продолжить использовать) репозиторий на GitHub/GitLab.
    *   В репозитории создать директорию `lab_3`.
2.  **Структура отчета:**
    *   Файл `README.md`:
        *   Текст задания вашего варианта.
        *   Описание хода работы.
        *   Код SQL-запросов и скриншоты результатов (или таблицы в Markdown).
        *   **Выводы** (анализ полученных данных).
    *   Файл `queries.sql`:
        *   Чистый SQL-код решений с комментариями.
3.  **Сдача работы:**
    *   В Moodle прикрепить **только ссылку** на репозиторий.

## Критерии оценки

*   **5 баллов.** Выполнены все 3 задания, код оптимален, `README.md` содержит полные выводы и скриншоты.
*   **4 балла.** Задания выполнены, но есть мелкие замечания по стилю кода или оформлению отчета.
*   **3 балла.** Выполнено 2 задания из 3, либо допущены ошибки в логике `HAVING`/`GROUP BY`.
*   **0-2 балла.** Задания не выполнены или код не работает.

```

